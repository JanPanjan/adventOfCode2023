}
game_IDs_sum <- 0
for (game in 1:nrow(df)) {
j <- 1
while (j < 19) {
colRange <- seq(j,j+2)[-2]
sum <- sumCubesByColor(col=df[game,colRange[1]:colRange[2]])
print(sum)
# če zaznamo prekoračen limit, končamo pregled vrednosti
if (!ok_vrednosti(sum)) {
break
} else {
# če so vse vrednosti v redu, dodamo index igre v sum
print(paste("game ID: ", game))
game_IDs_sum <- game_IDs_sum + game
print(game_IDs_sum)
j+3 -> j
}
}
if (i == 30) {
break
}
}
game_IDs_sum <- 0
for (game in 1:nrow(df)) {
j <- 1
while (j < 19) {
colRange <- seq(j,j+2)[-2]
sum <- sumCubesByColor(col=df[game,colRange[1]:colRange[2]])
print(sum)
# če zaznamo prekoračen limit, končamo pregled vrednosti
if (!ok_vrednosti(sum)) {
break
} else {
# če so vse vrednosti v redu, dodamo index igre v sum
print(paste("game ID: ", game))
game_IDs_sum <- game_IDs_sum + game
print(game_IDs_sum)
j+3 -> j
}
}
if (i == 30) {
break
}
}
game_IDs_sum <- 0
for (i in 1:nrow(df)) {
j <- 1
while (j < 19) {
colRange <- seq(j,j+2)[-2]
sum <- sumCubesByColor(col=df[i,colRange[1]:colRange[2]])
print(sum)
# če zaznamo prekoračen limit, končamo pregled vrednosti
if (!ok_vrednosti(sum)) {
break
} else {
# če so vse vrednosti v redu, dodamo index igre v sum
print(paste("game ID: ", i))
game_IDs_sum <- game_IDs_sum + i
print(game_IDs_sum)
j+3 -> j
}
}
if (i == 30) {
break
}
}
matrix(0, 100, 18)
matrix(0, 100, 6)
ok <- c(rep(0,100))
ok
ok[3]
ok[3] <- 3
ok
game_IDs_sum <- 0
# vektor hrani katere igre so v vredu
ok <- c(rep(0,100))
for (i in 1:nrow(df)) {
j <- 1
while (j < 19) {
colRange <- seq(j,j+2)[-2]
sum <- sumCubesByColor(col=df[i,colRange[1]:colRange[2]])
print(sum)
ok[i] <- i
# moramo pregledat vsev sete v igri
# set, ki ni v redu, ponastavi vrednost na 0 in gremo naprej
if (!ok_vrednosti(sum)) {
ok[i] <- 0
break
}
j+3 -> j
}
}
# vektor hrani katere igre so v vredu
ok <- c(rep(0,100))
for (i in 1:nrow(df)) {
j <- 1
while (j < 19) {
colRange <- seq(j,j+2)[-2]
sum <- sumCubesByColor(col=df[i,colRange[1]:colRange[2]])
print(sum)
ok[i] <- i
# moramo pregledat vsev sete v igri
# set, ki ni v redu, ponastavi vrednost na 0 in gremo naprej
if (!ok_vrednosti(sum)) {
ok[i] <- 0
break
}
j+3 -> j
}
if (i == 30) {
break
}
}
ok
# moram najt skupni seštevek istih kock za vsako rundo
# naredim vektor velikost 3 (rdeča, modra, zelena)
# vrednosti moram gledati rowwise
# naredim funkcijo ki bo parsala vrednost
#  - potrebujem število
#  - potrebujem barvo
#  - glede na barvo, pripišem vrednost v vektor
#  - če je NA, ni težav
# naredim to s celim stolpcem
# naredim to z vsemi stolpci
parseCubeData <- \(col) {
barve <- c(blue=0, green=0, red=0)
col <- as.character(col)
str_split(col, " ", n=3, simplify = T) %>%
.[,-1] -> middle
for (i in 1:nrow(middle)) {
barve[middle[i,2]] <- barve[middle[i,2]] + as.numeric(middle[i,1])
}
return(barve[1:3])
}
# če zdaj to probam s celo prvo vrstico
parseCubeData(col = df[1,])
# moram pa vzeti tri stolpce naenkrat
colnames(df) %>% length()
parseCubeData(col = df[1,13:15])
parseCubeData(col = df[1,16:18])
parseCubeData(col = df[1,10:12])
# za vsakim setom moramo preveriti, ali so vrednosti prekoralile limit
# modra: 14
# zelena: 13
# rdeča: 12
dosezenLimit <- \(kocke) {
if (kocke["blue"] > 14 | kocke["green"] > 13 | kocke["red"] > 12) {
return(TRUE)
} else {
return(FALSE)
}
}
dosezenLimit(parseCubeData(col = df[1,1:3]))
dosezenLimit(parseCubeData(col = df[1,4:6]))
dosezenLimit(parseCubeData(col = df[1,7:9]))
dosezenLimit(parseCubeData(col = df[1,10:12]))
# vektor hrani katere igre so v vredu
okIgre <- seq(1:100); okIgre
# gremo čez vsak game in vsak set v game-u
# ko najdemo nonvalid game, ga odstranimo iz seznama
for (game in 1:100) {
okGame <- TRUE
i <- 1
while (i < 19) {
cols <- c(i, i+2)
sum <- parseCubeData(col = df[game, cols[1]:cols[2]])
if (dosezenLimit(sum)) {
okGame <- FALSE
break
}
}
if (!okGame) {
okIgre[game] <- 0
}
if(i == 20) {
break
}
}
# gremo čez vsak game in vsak set v game-u
# ko najdemo nonvalid game, ga odstranimo iz seznama
for (game in 1:100) {
okGame <- TRUE
i <- 1
print(game)
while (i < 19) {
cols <- c(i, i+2)
sum <- parseCubeData(col = df[game, cols[1]:cols[2]])
if (dosezenLimit(sum)) {
okGame <- FALSE
break
}
}
if (!okGame) {
okIgre[game] <- 0
}
if(i == 20) {
break
}
}
# gremo čez vsak game in vsak set v game-u
# ko najdemo nonvalid game, ga odstranimo iz seznama
for (game in 1:100) {
okGame <- TRUE
i <- 1
print(game)
while (i < 19) {
cols <- c(i, i+2)
print(cols)
sum <- parseCubeData(col = df[game, cols[1]:cols[2]])
if (dosezenLimit(sum)) {
okGame <- FALSE
break
}
}
if (!okGame) {
okIgre[game] <- 0
}
if(i == 20) {
break
}
}
# gremo čez vsak game in vsak set v game-u
# ko najdemo nonvalid game, ga odstranimo iz seznama
for (game in 1:100) {
okGame <- TRUE
i <- 1
print(game)
while (i < 19) {
cols <- c(i, i+2)
print(cols)
kocke <- parseCubeData(col = df[game, cols[1]:cols[2]])
if (dosezenLimit(kocke)) {
print(dosežen limit.)
# gremo čez vsak game in vsak set v game-u
# ko najdemo nonvalid game, ga odstranimo iz seznama
for (game in 1:100) {
okGame <- TRUE
i <- 1
print(game)
while (i < 19) {
cols <- c(i, i+2)
print(cols)
kocke <- parseCubeData(col = df[game, cols[1]:cols[2]])
if (dosezenLimit(kocke)) {
print("dosežen limit.")
okGame <- FALSE
break
}
}
if (!okGame) {
okIgre[game] <- 0
}
if(i == 20) {
break
}
}
# gremo čez vsak game in vsak set v game-u
# ko najdemo nonvalid game, ga odstranimo iz seznama
for (game in 1:100) {
okGame <- TRUE
i <- 1
print(game)
while (i < 19) {
cols <- c(i, i+2)
print(cols)
kocke <- parseCubeData(col = df[game, cols[1]:cols[2]])
print(kocke)
if (dosezenLimit(kocke)) {
print("dosežen limit.")
okGame <- FALSE
break
}
}
if (!okGame) {
okIgre[game] <- 0
}
if(i == 20) {
break
}
}
# gremo čez vsak game in vsak set v game-u
# ko najdemo nonvalid game, ga odstranimo iz seznama
for (game in 1:100) {
okGame <- TRUE
i <- 1
print(game)
while (i < 19) {
kocke <- parseCubeData(col = df[game, i:i+2])
print(kocke)
if (dosezenLimit(kocke)) {
print("dosežen limit.")
okGame <- FALSE
break
}
}
if (!okGame) {
okIgre[game] <- 0
}
if(i == 20) {
break
}
}
# gremo čez vsak game in vsak set v game-u
# ko najdemo nonvalid game, ga odstranimo iz seznama
for (game in 1:100) {
okGame <- TRUE
i <- 1
print(game)
while (i < 19) {
kocke <- parseCubeData(col = df[game, i:i+2])
print(kocke)
if (dosezenLimit(kocke)) {
print("dosežen limit.")
okGame <- FALSE
break
}
}
if (!okGame) {
okIgre[game] <- 0
}
if(i == 20) {
break
}
}
# gremo čez vsak game in vsak set v game-u
# ko najdemo nonvalid game, ga odstranimo iz seznama
for (game in 1:100) {
okGame <- TRUE
i <- 1
print(game)
while (i < 19) {
cols <- c(i, i+2)
kocke <- parseCubeData(col = df[game, cols[1]:cols[2]])
print(kocke)
if (dosezenLimit(kocke)) {
print("dosežen limit.")
okGame <- FALSE
break
}
}
if (!okGame) {
okIgre[game] <- 0
}
if(i == 20) {
break
}
}
# gremo čez vsak game in vsak set v game-u
# ko najdemo nonvalid game, ga odstranimo iz seznama
for (game in 1:100) {
okGame <- TRUE
i <- 1
print(game)
while (i < 19) {
cols <- c(i, i+2)
kocke <- parseCubeData(col = df[game, cols[1]:cols[2]])
print(kocke)
if (dosezenLimit(kocke)) {
print("dosežen limit.")
okGame <- FALSE
i <- i+3
break
}
i <- i+3
}
if (!okGame) {
okIgre[game] <- 0
}
if(i == 20) {
break
}
}
# gremo čez vsak game in vsak set v game-u
# ko najdemo nonvalid game, ga odstranimo iz seznama
for (game in 1:100) {
okGame <- TRUE
i <- 1
while (i < 19) {
cols <- c(i, i+2)
kocke <- parseCubeData(col = df[game, cols[1]:cols[2]])
if (dosezenLimit(kocke)) {
print("dosežen limit.")
okGame <- FALSE
i <- i+3
break
}
i <- i+3
}
if (!okGame) {
okIgre[game] <- 0
}
if(i == 20) {
break
}
}
# gremo čez vsak game in vsak set v game-u
# ko najdemo nonvalid game, ga odstranimo iz seznama
for (game in 1:100) {
okGame <- TRUE
i <- 1
print(game)
while (i < 19) {
cols <- c(i, i+2)
kocke <- parseCubeData(col = df[game, cols[1]:cols[2]])
if (dosezenLimit(kocke)) {
print("dosežen limit.")
okGame <- FALSE
i <- i+3
break
}
i <- i+3
}
if (!okGame) {
okIgre[game] <- 0
}
if(i == 20) {
break
}
}
okIgre
options(width=141); quit(save = "yes")
options(width=67); setPower <- seq(1:100)
setPower
setPower <- rep(0,100)
setPower
setPower <- rep(rep(0,3), 100)
setPower
setPower <- list(rep(rep(0,3), 100))
setPower
setPower <- rep(rep(0,100), 100)
setPower
setPower <- rep(rep(0,3), 100)
setPower
setPowers <- matrix(0, 100,3)
setPowers
quit(save = "yes")
options(width=67); vec <- c(0,0,0)
v2 <- (1,2,1)
vec <- c(0,0,0)
v2 <- c(1,2,1)
for (i in 1:3) {
    if (vec[i] < v2[i]) {
      vec[i] <- v2[i]
  }
}
1:3) {
vec
vec <- c(3,0,1)
v2 <- c(1,2,1)
for (i in 1:3) {
    if (vec[i] < v2[i]) {
      vec[i] <- v2[i]
  }
}
vec
getMinSetPower <- \(currentMinValues, newValues) {
  for (i in 1:3) {
    if (currentMinValues[i] < newValues[i]) {
      currentMinValues[i] <- newValues[i]
    }
  return(currentMinValues)
}
getMinSetPower(1:3, 2:4)
getMinSetPower <- \(currentMinValues, newValues) {
  for (i in 1:3) {
    if (currentMinValues[i] < newValues[i]) {
      currentMinValues[i] <- newValues[i]
    }
  }
  return(currentMinValues)
}
getMinSetPower(1:3, 2:4)
parseCubeData <- \(col) {
  barve <- c(blue=0, green=0, red=0)
  col <- as.character(col)
  str_split(col, " ", n=3, simplify = T) %>% 
    .[,-1] -> middle 
  for (i in 1:nrow(middle)) {
    barve[middle[i,2]] <- as.numeric(middle[i,1])
  }
  return(barve[1:3])
}
dosezenLimit <- \(kocke) {
  if (kocke["blue"] > 14 | kocke["green"] > 13 | kocke["red"] > 12) {
    return(TRUE)
  } else {
    return(FALSE)
  }
}
return
}
}getMinSetPower <- \(currentMinValues, newValues) {
  for (i in 1:3) {
    if (currentMinValues[i] < newValues[i]) {
      currentMinValues[i] <- newValues[i]
    }
  }
  return(currentMinValues)
}
getMinSetPower <- \(currentMinValues, newValues) {
  for (i in 1:3) {
    if (currentMinValues[i] < newValues[i]) {
      currentMinValues[i] <- newValues[i]
    }
  }
  return(currentMinValues)
}
getMinSetPower(1:3, 2:4)
getMinSetPower(1:3, 1:4)
quit(save = "yes")
options(width=154); quit(save = "yes")
